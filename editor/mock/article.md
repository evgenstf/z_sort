# Word-RAM model
Чтобы давать теоритическую оценку времени выполнения алгоритмов, нужно ввести строгую математическую модель. Будем использовать модель **word-RAM** (где *RAM* расшифровывается, как *Random Access Machine* или *машина с произвольным доступом*). Опишем особенности этой модели:

 1. ***Один вычислитель*** = одно <!*Центральное Процессорное Устройство (ЦПУ)*!>[Как на английском?]{*англ. CPU - Central Processing Unit*}
2. ***Бесконечная одноранговая память***: содержит бесконечное количество ячеек, которые индексируются начиная с нуля. Каждая ячейка содержит либо *целое*, либо *вещественное* число, последнее хранится в экспоненциальном виде: $m \cdot 2^p$, где $m$ - мантисса числа.
3. <!***Арифметико-логическое устройство (АЛУ)***!>[Как на английском?]{*англ. ALU - Arithmetic Logic Unit*}, которое поддерживает:
	 * Арифметические операции: $+, -, *, div, mod$
	 * Логические операции: $<, >, ==$
	 * Битовые операции: $<<, >>, and, or, xor$
	 * *Математические операции**: $sin, cos, atan2, \sqrt{ }$ (квадратный корень)
	*$*$ - данные операции присутствуют в модели не всегда*
4. ***Разрешены операции:*** $\textit{\textbf{if, goto, a[i]}}$
5. ***Непрямая адресация***
6. ***Операции выполняются за*** $\textit{\textbf{O(1)}}$

Введем в нашу модель ограничения:

 1. ***Размер чисел***
	 * Давайте представим, что *входные данные* - это последовательность из $n$ целых чисел $a_1, a_2,..., a_n$, которая **непрерывно** записана где-то в оперативной памяти. (*Выходные данные* тоже представим последовательностью чисел: на выходе будем предъявлять начало блока памяти, в котором записан ответ, и явно об этом сигнализировать.)
	 * Пусть $С$ - некоторое ограничение на входные данные, то есть $C = max(a_1, a_2, ... , a_n)$
	 * Тогда размер чисел будет ограничен $poly(C, n, t(n))$, где $t(n)$ - время работы алгоритма.
	 * Слово *"word"* в названии **word-Ram** обозначает, что у нас появляется дополнительный параметр $w$ - размер чисел, с которыми можно оперировать, что позволяет использовать битовые операции.

 2. ***Память***
	  * Память бесконечная, но ограничим количество ячеек, которые можно использовать, $t(n)$. Пусть $num$ - максимальный номер ячейки памяти, которую мы будем использовать тогда должно быть выполнено: $$\exists \bar c: num \leq \bar c \cdot t(n)$$

# Оценка корректности алгоритмов
Когда мы предъявляем алгоритм для решения какой-либо задачи мы должны:

 * Доказать, что этот алгоритм решает поставленную задачу. Есть три способа сделать это:
	1. Доказательство по индукции
	2. Доказательство по инварианту
	3. Доказательство от противного
 * Дать оценку времени работы алгоритма $O(n)$. Также есть три способа:
	 1. Прямой учет
	 2. Амортизационный анализ
	 3. Анализ рекуррент

# Сортировки
**ЗАДАЧА:** дан массив из $n$ чисел, нужно отсортировать его за $O(n^2)$
### Сортировка пузырьком
*Описание:*
Пока существуют два соседних элемента, которые нарушают порядок сортировки, алгоритм проходится по массиву от начала до конца и меняет их местами.

*Псевдокод:*
```
for i: 1 to n
	for j: 1 to n-1
		if a[j] > a[j + 1]
			swap(a[j], a[j + 1]
```

### Сортировка выбором
*Описание:*
На $i$-ом шаге алгоритм проходится по массиву от первого элемента до элемента с индексом $n - i + 1$, выбирает из них максимальный и меняет местами с элементом с номером $n - i + 1$.

*Псевдокод:*
```
for i: 0 to n - 1
	p: a[p] = max(a[1], a[2], ..., a[n - i])
	swap(a[p], a[n - i])
```
*Доказательство по индукции:*
* База: $n = 1$: массив из одного элемента уже отсортирован
* Предположение: массив из $n$ элментов сортируется верно
* Переход: выберем максимальный элемент и вставим его в конец, отсортируем первые $n$ элементов, по предположению они отсортируются верно $\Rightarrow$ массив из $n + 1$ элементов будет остортирован верно.
### Сортировка вставкой
*Описание:*
Нa $i$-ом шаге первые $i$ элементов отсортированы. Рассмотрим $(i + 1)$-ый элемент и вставим его в первые $i$ элементов так, чтобы были отсортированы первые $i + 1$ элементов.

*Доказательство по инварианту:*
* Инвариант: после $i$ шагов первые $i$ элементов отсортированы
* Переход: покажем, что после $i + 1$ шага первые  $i + 1$ элементов отсортированы. Мы так вставляем $(i + 1)$-ый элемент, что инвариант сохраняется.
